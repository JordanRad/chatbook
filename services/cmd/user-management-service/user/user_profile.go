package user_profile

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/fit-smart/api/internal/auth/encryption"
	cloudstorage "github.com/fit-smart/api/internal/cloud_storage"

	"github.com/fit-smart/api/internal/logging"

	auth "github.com/fit-smart/api/internal/auth"
	"github.com/fit-smart/api/internal/gen/user"
	"github.com/fit-smart/api/internal/mail"
	"golang.org/x/crypto/bcrypt"
)

type Service struct {
	store        auth.UserStore
	cloudStorage cloudstorage.Storage
	encrypt      encryption.Encryption
	mailService  mail.Service
	logger       logging.DatabaseLogger
}

type LoginDetails struct {
	Email    string
	Password string
}

func NewService(store auth.UserStore,
	pictureStorage cloudstorage.Storage,
	encryption encryption.Encryption,
	mailService mail.Service,
	logger logging.DatabaseLogger) *Service {
	return &Service{
		store:        store,
		cloudStorage: pictureStorage,
		encrypt:      encryption,
		mailService:  mailService,
		logger:       logger,
	}
}

// Compile time assertion that this service implements the generated interface
var _ user.Service = (*Service)(nil)

// areSettingsValid checks if the settings payload contains empty strings
func areSettingsValid(settings user.BodyMetricsSettings) bool {
	return settings.Distance != "" && settings.Length != "" && settings.Weight != ""
}

func areNamesValid(fname, lname string) bool {
	return fname != "" && lname != ""
}

func (s *Service) Register(ctx context.Context, p *user.RegisterPayload) (*user.RegisterResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	if p.Password != p.ConfirmedPassword {
		return nil, user.MakeUnmatchingPassowrds(errors.New("Passwords do not match"))
	}

	encryptedPassword, err := s.encrypt.EncryptPassword(p.Password)
	if err != nil {
		return nil, fmt.Errorf("error encrypting password: %w", err)
	}

	newUser := &auth.User{
		Email:     p.Email,
		FirstName: p.FirstName,
		LastName:  p.LastName,
		Password:  encryptedPassword,
		Role:      auth.Role(p.Role),
		Settings:  auth.Settings(*p.Settings),
	}

	_, err = s.store.Register(ctx, newUser)
	if err != nil {
		return nil, fmt.Errorf("error creating new user: %w", err)
	}

	err = s.mailService.SendEmail(fmt.Sprintf("%v %v", newUser.FirstName, newUser.LastName), newUser.Email)
	if err != nil {
		s.logger.Log(ctx, logging.NewEventLog(0, "Register", fmt.Sprintf("silent error: %v", err.Error()), logging.ErrorLogLevel))
	}

	response := &user.RegisterResponse{
		Message: "User has been registered successfully",
	}

	return response, nil
}

func (s *Service) GetUserProfile(ctx context.Context) (*user.UserProfileResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting user from context: %w", err)
	}
	result, err := s.store.GetUserByEmail(ctx, u.Email)

	if err != nil {
		return nil, fmt.Errorf("error getting user profile: %w", err)
	}

	response := &user.UserProfileResponse{
		ID:         result.ID,
		FirstName:  result.FirstName,
		LastName:   result.LastName,
		Email:      result.Email,
		Role:       string(result.Role),
		Settings:   (*user.BodyMetricsSettings)(&result.Settings),
		PictureURL: result.PictureURL,
	}
	return response, nil
}

func (s *Service) UpdateSettings(ctx context.Context, p *user.UpdateSettingsPayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting user from context: %w", err)
	}
	if !areSettingsValid(*p.Settings) {
		return nil, fmt.Errorf("settings payload is incomplete")
	}
	err = s.store.UpdateUserSettings(ctx, int(u.ID), auth.Settings(*p.Settings))
	if err != nil {
		return nil, fmt.Errorf("error updating user settings: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "User settings have been updated successfully",
	}
	return r, nil
}

func (s *Service) UpdateProfileNames(ctx context.Context, p *user.UpdateProfileNamesPayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting token claims: %w", err)
	}

	if !areNamesValid(p.FirstName, p.LastName) {
		return nil, fmt.Errorf("names payload is incomplete")
	}

	err = s.store.UpdateProfileNames(ctx, int(u.ID), p.FirstName, p.LastName)
	if err != nil {
		return nil, fmt.Errorf("error updating user settings: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "Profile names have been updated successfully",
	}
	return r, nil
}

func (s *Service) UpdatePassword(ctx context.Context, p *user.UpdatePasswordPayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting token claims: %w", err)
	}

	isOldPwCorrect := s.encrypt.CheckPassword(u.Password, p.OldPassword)
	if !isOldPwCorrect {
		return nil, fmt.Errorf("current password incorrect")
	}

	newPw, err := s.encrypt.EncryptPassword(p.NewPassword)
	if err != nil {
		return nil, fmt.Errorf("error encrypting password: %w", err)
	}

	err = s.store.UpdatePassword(ctx, int(u.ID), newPw)
	if err != nil {
		return nil, fmt.Errorf("error updating user password: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "User password has been updated successfully",
	}
	return r, nil
}

func (s *Service) ResetPassword(ctx context.Context, p *user.ResetPasswordPayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := s.store.GetUserByEmail(ctx, p.Email)
	if err != nil {
		return nil, fmt.Errorf("error getting user profile: %w", err)
	}

	pw, err := s.encrypt.EncryptPassword(p.Password)
	if err != nil {
		return nil, fmt.Errorf("error encrypting password: %w", err)
	}

	err = s.store.UpdatePassword(ctx, int(u.ID), pw)
	if err != nil {
		return nil, fmt.Errorf("error updating user password: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "User password has been updated successfully",
	}
	return r, nil
}

func (s *Service) RecoverPassword(ctx context.Context, p *user.RecoverPasswordPayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := s.store.GetUserByEmail(ctx, p.Email)
	if err != nil {
		return nil, fmt.Errorf("error getting user profile: %w", err)
	}

	err = s.mailService.SendEmail(u.FirstName, p.Email)
	if err != nil {
		return nil, fmt.Errorf("error generating email: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "Password recovery email successfully sent",
	}
	return r, nil
}

func (s *Service) DeleteUser(ctx context.Context) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting token claims: %w", err)
	}

	err = s.store.DeleteUser(ctx, int(u.ID))
	if err != nil {
		return nil, fmt.Errorf("error deleting user: %w", err)
	}

	r := &user.OperationStatusResponse{
		Message: "User has been deleted successfully",
	}
	return r, nil
}

func (s *Service) UploadPicture(ctx context.Context, p *user.UploadPicturePayload) (*user.OperationStatusResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := auth.UserInContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("error extracting token claims: %w", err)
	}

	picName, err := generatePictureName(p.Name)
	if err != nil {
		return nil, fmt.Errorf("error gnerating unique picture name: %w", err)
	}

	err = s.cloudStorage.UploadPicture(ctx, p.Content, picName, p.Format)
	if err != nil {
		return nil, fmt.Errorf("error uploading profile picture: %w", err)
	}

	err = s.store.UpdateProfilePicture(ctx, u.ID, getPictureURL(picName))
	if err != nil {
		return nil, fmt.Errorf("error updating picture url: %w", err)
	}
	response := &user.OperationStatusResponse{Message: "Profile picture has been uploaded successfully."}
	return response, nil
}

func generatePictureName(name string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(name), 3)
	if err != nil {
		return "", fmt.Errorf("error encrypting name: %w", err)
	}
	uh := strings.ReplaceAll(string(hash), "/", "_")

	gen := fmt.Sprintf("%v_%v", time.Now().UnixMilli(), uh)
	return gen, nil
}

func getPictureURL(name string) string {
	return fmt.Sprintf("https://storage.googleapis.com/smart-fit-355914.appspot.com/pictures-dev/%v", name)
}
