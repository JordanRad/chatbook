package user_auth

import (
	"context"
	"errors"
	"fmt"

	"github.com/fit-smart/api/internal/logging"

	auth "github.com/fit-smart/api/internal/auth"
	"github.com/fit-smart/api/internal/auth/encryption"
	"github.com/fit-smart/api/internal/auth/google_oauth"
	"github.com/fit-smart/api/internal/auth/jwt"
	authgen "github.com/fit-smart/api/internal/gen/auth"
	"github.com/fit-smart/api/internal/mail"
)

type Service struct {
	store       auth.UserStore
	googleOAuth googleoauth.GoogleRegistry
	encrypt     encryption.Encryption
	jwt         jwt.JWTClient
	mailService mail.Service
	logger      logging.DatabaseLogger
}

type LoginDetails struct {
	Email    string
	Password string
}

func NewService(store auth.UserStore,
	googleOAuth googleoauth.GoogleRegistry,
	encrypt encryption.Encryption,
	jwt jwt.JWTClient,
	mailService mail.Service,
	logger logging.DatabaseLogger) *Service {
	return &Service{
		store:       store,
		googleOAuth: googleOAuth,
		encrypt:     encrypt,
		jwt:         jwt,
		mailService: mailService,
		logger:      logger,
	}
}

// Compile time assertion that this service implements the generated interface
var _ = (*Service)(nil)

func (s *Service) Login(ctx context.Context, p *authgen.LoginPayload) (*authgen.LoginResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	foundUser, err := s.store.GetUserByEmail(ctx, p.Email)

	if err != nil {
		err := authgen.MakeWrongCredentials(err)
		return nil, err
	}

	isPasswordCorrect := s.encrypt.CheckPassword(foundUser.Password, p.Password)
	if !isPasswordCorrect {
		err := authgen.MakeWrongCredentials(errors.New("password is not correct"))
		return nil, err
	}

	t, err := s.jwt.GenerateJWT(uint(foundUser.ID), foundUser.Email, string(foundUser.Role), false)
	if err != nil {
		return nil, fmt.Errorf("error extracting jwt: %w", err)
	}

	rt, err := s.jwt.GenerateJWT(uint(foundUser.ID), foundUser.Email, string(foundUser.Role), true)
	if err != nil {
		return nil, fmt.Errorf("error generating refresh token: %w", err)
	}

	response := &authgen.LoginResponse{
		Email:        p.Email,
		Token:        t,
		RefreshToken: rt,
		Role:         string(foundUser.Role),
	}
	return response, nil
}

func (s *Service) LoginGoogle(ctx context.Context, p *authgen.LoginGooglePayload) (*authgen.LoginResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	if p.Token == "" || p.RefreshToken == "" {
		return nil, errors.New("request body for oauth login is not completed")
	}

	gu, err := s.googleOAuth.GetUserInfo(ctx, p.Token)
	if err != nil {
		return nil, fmt.Errorf("error getting user info: %w", err)
	}

	if !gu.VerifiedEmail {
		return nil, errors.New("your Google account is not verified")
	}

	eu, err := s.store.GetUserByEmail(ctx, gu.Email)
	if err != nil && !errors.Is(err, &auth.ErrUserNotFound{}) {
		return nil, fmt.Errorf("error retrieving user with this email: %w", err)
	}
	// If user is not found, register and create a token
	if err != nil && errors.Is(err, &auth.ErrUserNotFound{}) {
		toRegister := &auth.User{
			Email:     gu.Email,
			FirstName: gu.FirstName,
			LastName:  gu.LastName,
			//NOTE(JordanRad): Get role from payload
			Role: auth.RoleUser,
			//NOTE(JordanRad): Get settings from payload
			Settings:   auth.Settings{Length: "cm", Distance: "km", Weight: "kg"},
			Password:   "",
			PictureURL: gu.PictureURL,
		}
		registered, err := s.store.Register(ctx, toRegister)
		if err != nil {
			return nil, fmt.Errorf("error regisreting new user: %w", err)
		}

		t, err := s.jwt.GenerateJWT(uint(registered.ID), registered.Email, string(registered.Role), false)
		if err != nil {
			return nil, fmt.Errorf("error generating JWT: %w", err)
		}

		rt, err := s.jwt.GenerateJWT(uint(registered.ID), registered.Email, string(registered.Role), true)
		if err != nil {
			return nil, fmt.Errorf("error generating refresh token: %w", err)
		}

		response := &authgen.LoginResponse{
			Email:        registered.Email,
			Token:        t,
			RefreshToken: rt,
			Role:         string(registered.Role),
			ID:           nil,
		}
		return response, nil

	}

	t, err := s.jwt.GenerateJWT(uint(eu.ID), eu.Email, string(eu.Role), false)
	if err != nil {
		return nil, fmt.Errorf("error generating JWT: %w", err)
	}

	rt, err := s.jwt.GenerateJWT(uint(eu.ID), eu.Email, string(eu.Role), true)
	if err != nil {
		return nil, fmt.Errorf("error generating refresh token: %w", err)
	}

	response := &authgen.LoginResponse{
		Email:        eu.Email,
		Token:        t,
		RefreshToken: rt,
		Role:         string(eu.Role),
		ID:           nil,
	}

	return response, nil
}

func (s *Service) RefreshToken(ctx context.Context, p *authgen.RefreshTokenPayload) (*authgen.LoginResponse, error) {
	// DO NOT EDIT THIS CODE. IT HAS BEEN GENERATED BY LOGEN TOOL
	e := logging.NewEventLog(0, logging.FindCurrentFuncName(), "Service method", logging.InfoLogLevel)
	s.logger.Log(ctx, e)

	u, err := s.store.GetUserByEmail(ctx, p.Email)
	if err != nil {
		return nil, fmt.Errorf("error retrieving user from the database: %w", err)
	}

	_, err = s.jwt.ValidateJWT(p.RefreshToken)
	if err != nil {
		return nil, fmt.Errorf("error validating refresh token: %w", err)
	}

	t, err := s.jwt.GenerateJWT(uint(u.ID), u.Email, string(u.Role), false)
	if err != nil {
		return nil, fmt.Errorf("error generating token: %w", err)
	}

	rt, err := s.jwt.GenerateJWT(uint(u.ID), u.Email, string(u.Role), true)
	if err != nil {
		return nil, fmt.Errorf("error generating refresh token: %w", err)
	}

	r := &authgen.LoginResponse{
		Email:        u.Email,
		Token:        t,
		RefreshToken: rt,
		Role:         string(u.Role),
		ID:           nil,
	}
	return r, nil
}
