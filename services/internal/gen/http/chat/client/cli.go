// Code generated by goa v3.11.3, DO NOT EDIT.
//
// chat HTTP client CLI support package
//
// Command:
// $ goa gen github.com/JordanRad/chatbook/services/internal/design -o
// ./internal

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	chat "github.com/JordanRad/chatbook/services/internal/gen/chat"
	goa "goa.design/goa/v3/pkg"
)

// BuildGetConversationHistoryPayload builds the payload for the chat
// getConversationHistory endpoint from CLI flags.
func BuildGetConversationHistoryPayload(chatGetConversationHistoryID string, chatGetConversationHistoryLimit string, chatGetConversationHistoryBeforeTimestamp string) (*chat.GetConversationHistoryPayload, error) {
	var err error
	var id string
	{
		id = chatGetConversationHistoryID
	}
	var limit string
	{
		if chatGetConversationHistoryLimit != "" {
			limit = chatGetConversationHistoryLimit
		}
	}
	var beforeTimestamp int64
	{
		if chatGetConversationHistoryBeforeTimestamp != "" {
			beforeTimestamp, err = strconv.ParseInt(chatGetConversationHistoryBeforeTimestamp, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("invalid value for beforeTimestamp, must be INT64")
			}
		}
	}
	v := &chat.GetConversationHistoryPayload{}
	v.ID = id
	v.Limit = limit
	v.BeforeTimestamp = beforeTimestamp

	return v, nil
}

// BuildSearchInConversationPayload builds the payload for the chat
// searchInConversation endpoint from CLI flags.
func BuildSearchInConversationPayload(chatSearchInConversationID string, chatSearchInConversationLimit string, chatSearchInConversationSearchInput string) (*chat.SearchInConversationPayload, error) {
	var err error
	var id string
	{
		id = chatSearchInConversationID
	}
	var limit string
	{
		if chatSearchInConversationLimit != "" {
			limit = chatSearchInConversationLimit
		}
	}
	var searchInput string
	{
		if chatSearchInConversationSearchInput != "" {
			searchInput = chatSearchInConversationSearchInput
			if utf8.RuneCountInString(searchInput) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("searchInput", searchInput, utf8.RuneCountInString(searchInput), 5, true))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &chat.SearchInConversationPayload{}
	v.ID = id
	v.Limit = limit
	v.SearchInput = searchInput

	return v, nil
}

// BuildGetConversationsListPayload builds the payload for the chat
// getConversationsList endpoint from CLI flags.
func BuildGetConversationsListPayload(chatGetConversationsListBody string, chatGetConversationsListLimit string) (*chat.GetConversationsListPayload, error) {
	var err error
	var body GetConversationsListRequestBody
	{
		err = json.Unmarshal([]byte(chatGetConversationsListBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ID\": \"Suscipit qui nesciunt consequatur quia repellat.\"\n   }'")
		}
	}
	var limit string
	{
		if chatGetConversationsListLimit != "" {
			limit = chatGetConversationsListLimit
		}
	}
	v := &chat.GetConversationsListPayload{
		ID: body.ID,
	}
	v.Limit = limit

	return v, nil
}

// BuildAddConversationPayload builds the payload for the chat addConversation
// endpoint from CLI flags.
func BuildAddConversationPayload(chatAddConversationBody string) (*chat.AddConversationPayload, error) {
	var err error
	var body AddConversationRequestBody
	{
		err = json.Unmarshal([]byte(chatAddConversationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"participants\": [\n         {\n            \"email\": \"Sint quasi et.\",\n            \"firstName\": \"Consequatur voluptatem.\",\n            \"id\": \"Ab est.\",\n            \"lastName\": \"Libero inventore in tempore.\"\n         },\n         {\n            \"email\": \"Sint quasi et.\",\n            \"firstName\": \"Consequatur voluptatem.\",\n            \"id\": \"Ab est.\",\n            \"lastName\": \"Libero inventore in tempore.\"\n         }\n      ]\n   }'")
		}
		if body.Participants == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("participants", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &chat.AddConversationPayload{}
	if body.Participants != nil {
		v.Participants = make([]*chat.Friend, len(body.Participants))
		for i, val := range body.Participants {
			v.Participants[i] = marshalFriendRequestBodyToChatFriend(val)
		}
	}

	return v, nil
}
